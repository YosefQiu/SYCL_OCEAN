#include "MPASOSolution.h"
#include "Interpolation.hpp"
void MPASOSolution::initSolution(MPASOReader* reader)
{
    this->mCurrentTime = std::move(reader->currentTimestep);
    this->mCellsSize = reader->mCellsSize;
    this->mEdgesSize = reader->mEdgesSize;
    this->mMaxEdgesSize = reader->mMaxEdgesSize;
    this->mVertexSize = reader->mVertexSize;
    this->mTimesteps = reader->mTimesteps;
    this->mVertLevels = reader->mVertLevels;
    this->mVertLevelsP1 = reader->mVertLevelsP1;

    this->cellVelocity_vec = std::move(reader->cellVelocity_vec);
    this->cellLayerThickness_vec = std::move(reader->cellLayerThickness_vec);
    this->cellZTop_vec = std::move(reader->cellZTop_vec);
    this->cellVertVelocity_vec = std::move(reader->cellVertVelocity_vec);
    this->cellNormalVelocity_vec = std::move(reader->cellNormalVelocity_vec);
    this->cellMeridionalVelocity_vec = std::move(reader->cellMeridionalVelocity_vec);
    this->cellZonalVelocity_vec = std::move(reader->cellZonalVelocity_vec);
    this->cellBottomDepth_vec = std::move(reader->cellBottomDepth_vec);

    // calcCellCenterZtop();
}

void MPASOSolution::getCellVelocity(const size_t cell_id, const size_t level, std::vector<vec3f>& cell_on_velocity, vec3f& vel)
{
    auto VertLevels = mVertLevels;
    if (VertLevels == -1 || VertLevels == 0)
    {
        Debug("ERROR, VertLevels is not defined");
    }
    auto idx = VertLevels * cell_id + level;
    vel = cell_on_velocity[idx];
}

void MPASOSolution::getCellVertVelocity(const size_t cell_id,
    const size_t level,
    std::vector<double>& cell_vert_velocity,
    double& vel)
{
    auto VertLevelsP1 = mVertLevelsP1;
    if (VertLevelsP1 == -1 || VertLevelsP1 == 0)
    {
        Debug("ERROR, VertLevelsP1 is not defined");
    }
    auto idx = VertLevelsP1 * cell_id + level;
    vel = cell_vert_velocity[idx];
}

void MPASOSolution::getCellZTop(const size_t cell_id, const size_t level, std::vector<double>& cell_ztop, double& ztop)
{
    // 单元格0，层0的顶部Z坐标
    // 单元格0，层1的顶部Z坐标
    // 单元格0，层2的顶部Z坐标
    // 单元格1，层0的顶部Z坐标
    // 单元格1，层1的顶部Z坐标
    // 单元格1，层2的顶部Z坐标
    auto VertLevels = mVertLevels;
    if (VertLevels == -1 || VertLevels == 0)
    {
        Debug("ERROR, VertLevels is not defined");
    }
    auto idx = VertLevels * cell_id + level;
    ztop = cell_ztop[idx];
}

void MPASOSolution::getEdgeNormalVelocity(const size_t edge_id, const size_t level, std::vector<double>& edge_normal_velocity, double& vel)
{
    auto VertLevels = mVertLevels;
    if (VertLevels == -1 || VertLevels == 0)
    {
        Debug("ERROR, VertLevels is not defined");
    }
    auto idx = VertLevels * edge_id + level;
    vel = edge_normal_velocity[idx];
}

void MPASOSolution::getCellLayerThickness(const size_t cell_id, const size_t level, std::vector<double>& cell_thickness, double& thinckness)
{
    // 单元格0，层0的厚度
    // 单元格0，层1的厚度
    // 单元格0，层2的厚度
    // 单元格1，层0的厚度
    // 单元格1，层1的厚度
    // 单元格1，层2的厚度

    auto VertLevels = mVertLevels;
    if (VertLevels == -1 || VertLevels == 0)
    {
        Debug("ERROR, VertLevels is not defined");
    }
    auto idx = VertLevels * cell_id + level;
    thinckness = cell_thickness[idx];
}

void MPASOSolution::getCellSurfaceMeridionalVelocity(const size_t cell_id, std::vector<double>& cell_meridional_velocity, double& vel)
{
    vel = cell_meridional_velocity[cell_id];
}

void MPASOSolution::getCellSurfaceZonalVelocity(const size_t cell_id, std::vector<double>& cell_zonal_velocity, double& vel)
{
    vel = cell_zonal_velocity[cell_id];
}

void MPASOSolution::getCellVertexZTop(const size_t cell_id, const size_t level, std::vector<double>& cell_vertex_ztop, std::vector<double>& ztop)
{
    size_t baseIndex = cell_id * 60 * 7 + level * 7;

    // Retrieve the 7 vertex ZTop values
    std::vector<double> vertexZTopValues;
    for (size_t i = 0; i < 7; ++i) {
        vertexZTopValues.push_back(cellVertexZTop_vec[baseIndex + i]);
    }
}


void MPASOSolution::calcCellCenterZtop()
{
    Debug(("[MPASOSolution]::Calc Cell Center Z Top at t = " + std::to_string(mCurrentTime)).c_str());

    // 1. 判断是否有layerThickness
    if (cellLayerThickness_vec.empty())
    {
        Debug("ERROR, cellLayerThickness is not defined");
        exit(0);
    }

    // 2. 计算ZTop
    auto nCellsSize = mCellsSize;
    //auto nVertLevelsP1      =  mVertLevelsP1;
    auto nVertLevels = mVertLevels;
    auto nTimesteps = mCurrentTime;

    std::cout << "=======\n";
    std::cout << "nCellsSize = " << nCellsSize << std::endl;
    //std::cout << "nVertLevelsP1 = " << nVertLevelsP1 << std::endl;
    std::cout << "nVertLevels = " << nVertLevels << std::endl;
    std::cout << "nTimesteps = " << nTimesteps << std::endl;

    if (!cellZTop_vec.empty()) cellZTop_vec.clear();
    cellZTop_vec.resize(nCellsSize * nVertLevels);

    for (size_t i = 0; i < nCellsSize; ++i)
    {
        // 初始化最顶层
        cellZTop_vec[i * nVertLevels] = 0.0f;
        for (size_t j = 1; j < nVertLevels; ++j)
        {
            double layerThickness;
            getCellLayerThickness(i, j - 1, cellLayerThickness_vec, layerThickness);
            cellZTop_vec[i * nVertLevels + j] = cellZTop_vec[i * nVertLevels + j - 1] - layerThickness;
        }
    }



    for (auto i = 0; i < cellZTop_vec.size(); ++i)
    {
        cellZTop_vec[i] *= 1.0f;
    }

    mTotalZTopLayer = nVertLevels;

    std::cout << "cellZTop_vec.size() = " << cellZTop_vec.size() << std::endl;
    std::cout << "nCellSize x nVertLevels = " << nCellsSize * nVertLevels << std::endl;
}
void saveDataToTextFile(const std::vector<double>& data, const std::string& filename) {
    std::ofstream outfile(filename);
    if (!outfile.is_open()) {
        std::cerr << "Failed to open file: " << filename << std::endl;
        return;
    }

    int count = 0;
    for (const auto& value : data) {
        outfile << value << " ";
        count++;
        if (count % 7 == 0) {
            outfile << std::endl;
        }
    }

    if (count % 7 != 0) {  // 如果数据总数不是7的倍数，在文件末尾添加换行
        outfile << std::endl;
    }

    outfile.close();
    std::cout << "Data saved to " << filename << std::endl;
}
void MPASOSolution::calcCellVertexZtop(MPASOGrid* grid, sycl::queue& q)
{
    Debug(("[MPASOSolution]::Calc Cell Vertex Z Top at t = " + std::to_string(mCurrentTime)).c_str());
    
    cellVertexZTop_vec.clear();
    cellVertexZTop_vec.resize(mCellsSize * mTotalZTopLayer * 7);


    sycl::buffer<vec3f, 1> vertexCoord_buf(grid->vertexCoord_vec.data(), sycl::range<1>(grid->vertexCoord_vec.size())); // CELL 顶点坐标
    sycl::buffer<vec3f, 1> cellCoord_buf(grid->cellCoord_vec.data(), sycl::range<1>(grid->cellCoord_vec.size()));       // CELL 中心坐标

    sycl::buffer<size_t, 1> numberVertexOnCell_buf(grid->numberVertexOnCell_vec.data(), sycl::range<1>(grid->numberVertexOnCell_vec.size())); // CELL 有几个顶点
    sycl::buffer<size_t, 1> verticesOnCell_buf(grid->verticesOnCell_vec.data(), sycl::range<1>(grid->verticesOnCell_vec.size()));             // 
    sycl::buffer<size_t, 1> cellsOnVertex_buf(grid->cellsOnVertex_vec.data(), sycl::range<1>(grid->cellsOnVertex_vec.size()));

    sycl::buffer<double, 1> cellCenterZTop_buf(cellZTop_vec.data(), sycl::range<1>(cellZTop_vec.size()));                           //CELL 中心ZTOP
    sycl::buffer<double, 1> cellVertexZTop_buf(cellVertexZTop_vec.data(), sycl::range<1>(mCellsSize * mTotalZTopLayer * 7));        //CELL 顶点ZTOP （要求的）

    q.submit([&](sycl::handler& cgh) {
        
        auto acc_vertexCoord_buf        = vertexCoord_buf.get_access<sycl::access::mode::read>(cgh);
        auto acc_cellCoord_buf          = cellCoord_buf.get_access<sycl::access::mode::read>(cgh);
        auto acc_numberVertexOnCell_buf = numberVertexOnCell_buf.get_access<sycl::access::mode::read>(cgh);
        auto acc_verticesOnCell_buf     = verticesOnCell_buf.get_access<sycl::access::mode::read>(cgh);
        auto acc_cellsOnVertex_buf      = cellsOnVertex_buf.get_access<sycl::access::mode::read>(cgh);
        auto acc_cellCenterZTop_buf     = cellCenterZTop_buf.get_access<sycl::access::mode::read>(cgh);
        auto acc_cellVertexZTop_buf     = cellVertexZTop_buf.get_access<sycl::access::mode::read_write>(cgh);
        
        cgh.parallel_for(sycl::range<2>(mCellsSize, mTotalZTopLayer), [=](sycl::id<2> idx) {
            size_t j = idx[0];
            size_t i = idx[1]; 

            auto cell_id = j;
            auto current_layer = i;

            const int CELL_SIZE = 235160;
            const int VERTEX_NUM = 7;
            const int NEIGHBOR_NUM = 3;
            const int TOTAY_ZTOP_LAYER = 60;
            const int VERTLEVELS = 60;
            // 1. 找出这个cell 的所有顶点 不存在的置为nan
            
            // 1.1 计算这个CELL 有多少个顶点
            auto current_cell_vertices_number = acc_numberVertexOnCell_buf[cell_id];
            // 1.2 找出所有候选顶点
            size_t current_cell_vertices_idx[VERTEX_NUM];
            for (size_t k = 0; k < VERTEX_NUM; ++k)
            {
                current_cell_vertices_idx[k] = acc_verticesOnCell_buf[cell_id * 7 + k] - 1; // Assuming 7 is the max number of vertices per cell
            }
            // 1.3 不存在的顶点设置为nan
            auto nan = std::numeric_limits<size_t>::max();
            for (size_t k = current_cell_vertices_number; k < VERTEX_NUM; ++k)
            {
                current_cell_vertices_idx[k] = nan;
            }
            // =============================== 找到7个顶点

            double current_cell_vertices_value[VERTEX_NUM];
            bool bBoundary = false;
            for (auto k = 0; k < VERTEX_NUM; ++k)
            {
                auto vertex_idx = current_cell_vertices_idx[k];
                // 2.1 如果是nan 跳过
                if (vertex_idx == nan) { current_cell_vertices_value[k] = std::numeric_limits<double>::quiet_NaN(); continue; }
                auto current_vertex = acc_vertexCoord_buf[vertex_idx];
                // 2.2 如果不是nan 找到含有这个顶点的3个cell id(候选) 边界情况没有3个
                size_t tmp_cell_id[3];
                tmp_cell_id[0] = acc_cellsOnVertex_buf[3 * vertex_idx + 0] - 1;
                tmp_cell_id[1] = acc_cellsOnVertex_buf[3 * vertex_idx + 1] - 1;
                tmp_cell_id[2] = acc_cellsOnVertex_buf[3 * vertex_idx + 2] - 1;
                // 2.3 找到这3个CELL 的中心ZTOP
                double tmp_cell_center_ztop[3];
                for (auto tmp_cell = 0; tmp_cell < NEIGHBOR_NUM; tmp_cell++)
                {
                    double value;
                    if (tmp_cell_id[tmp_cell] > CELL_SIZE + 1)
                    {
                        value = 0.0;
                        tmp_cell_center_ztop[tmp_cell] = value;
                        bBoundary = true;
                    }
                    else
                    {
                        double ztop;
                        auto ztop_idx = VERTLEVELS * tmp_cell_id[tmp_cell] + current_layer;
                        ztop = acc_cellCenterZTop_buf[ztop_idx];
                        tmp_cell_center_ztop[tmp_cell] = ztop;
                    }
                }
                //current_cell_vertices_value[k] = 1.0 * tmp_cell_center_ztop[0] + 1.0 * tmp_cell_center_ztop[1] + 1.0 * tmp_cell_center_ztop[2];


                // 2.4 如果是边界点
                if (bBoundary)
                {
                    current_cell_vertices_value[k] = 0.0 * tmp_cell_center_ztop[0] + 0.0 * tmp_cell_center_ztop[1] + 0.0 * tmp_cell_center_ztop[2];
                }
                else
                {
                    float u, v, w;
                    vec3f p1 = acc_cellCoord_buf[tmp_cell_id[0]];
                    vec3f p2 = acc_cellCoord_buf[tmp_cell_id[1]];
                    vec3f p3 = acc_cellCoord_buf[tmp_cell_id[2]];
                    Interpolator::TRIANGLE tri(p1, p2, p3);
                    Interpolator::calcTriangleBarycentric(current_vertex, &tri, u, v, w);
                    current_cell_vertices_value[k] = u * tmp_cell_center_ztop[0] + v * tmp_cell_center_ztop[1] + w * tmp_cell_center_ztop[2];
                }
            }
        

            for (size_t k = 0; k < 7; ++k) {
                acc_cellVertexZTop_buf[j * TOTAY_ZTOP_LAYER * 7 + i * 7 + k] = current_cell_vertices_value[k];
                //acc_cellVertexZTop_buf[j * TOTAY_ZTOP_LAYER * 7 + i * 7 + k] = current_cell_vertices_idx[k];
            }

        });
    });
    q.wait_and_throw();
    Debug("finished the sycl part");
    auto host_accessor = cellVertexZTop_buf.get_access<sycl::access::mode::read>();
    auto range = host_accessor.get_range();
    size_t acc_length = range.size(); // 获取缓冲区的总大小

    std::cout << "cellVertexZTop_vec.size() = " << cellVertexZTop_vec.size() << " " << acc_length << std::endl;
    saveDataToTextFile(cellVertexZTop_vec, "OUTPUT1_ztop.txt");
    Debug("finish1");


    //cellVertexZTop_vec.clear();

    //for (auto j = 0; j < mCellsSize; ++j)
    //{
    //    for (auto i = 0; i < mTotalZTopLayer; ++i)
    //    {
    //        auto cell_id = j;
    //        auto current_layer = i;
    //        // 1.1 找出这个cell 的所有顶点
    //        std::vector<size_t> current_cell_vertices_idx;
    //        // 1.2 计算这个cell 有多少个顶点
    //        auto current_cell_vertices_number = grid->numberVertexOnCell_vec[cell_id];
    //        grid->getVerticesOnCell(cell_id, grid->verticesOnCell_vec, current_cell_vertices_idx);
    //        // 1.3 不存在的顶点设置为nan
    //        auto nan = std::numeric_limits<size_t>::max();
    //        if (current_cell_vertices_idx.size() != current_cell_vertices_number)
    //        {
    //            auto length = current_cell_vertices_idx.size() - current_cell_vertices_number;
    //            current_cell_vertices_idx.resize(current_cell_vertices_number);
    //            current_cell_vertices_idx.insert(current_cell_vertices_idx.end(), length, nan);
    //        }
    //        //=========================== 找到7个顶点 V

    //        


    //        std::vector<double> current_cell_vertices_value;
    //        if (!current_cell_vertices_value.empty()) current_cell_vertices_value.clear();
    //        current_cell_vertices_value.resize(current_cell_vertices_idx.size());

    //        // 遍历7个顶点来计算7个顶点的ZTOP 存在current_cell_vertices_value
    //        bool bBoundary = false;
    //        for (auto k = 0; k < current_cell_vertices_idx.size(); ++k)
    //        {
    //            // 如果是nan 值 就跳过
    //            if (current_cell_vertices_idx[k] == nan) { current_cell_vertices_value[k] = std::numeric_limits<double>::quiet_NaN(); continue; };

    //            // 找出这个顶点的坐标
    //            auto vertex_idx = current_cell_vertices_idx[k];
    //            auto current_vertex = grid->vertexCoord_vec[vertex_idx];
    //            // 找出这个顶点的所有CELL 预计3个
    //            std::vector<size_t> tmp_cell_id;
    //            grid->getCellsOnVertex(vertex_idx, grid->cellsOnVertex_vec, tmp_cell_id);

    //            std::vector<double> tmp_cell_center_ztop; // 用来存相邻的这个3个CELL的中心ZTOP
    //            if (!tmp_cell_center_ztop.empty()) tmp_cell_center_ztop.clear();
    //            tmp_cell_center_ztop.resize(3);
    //            // 遍历这3个CELL，分别找出存在中心的CELL的ZTOP
    //            for (auto tmp_cell = 0; tmp_cell < 3; tmp_cell++)
    //            {
    //                double value;
    //                // 这个CELL是边界CELL，不存在3个邻接CELL
    //                if (tmp_cell_id[tmp_cell] > grid->mCellsSize + 1)
    //                {
    //                    value = double(0.0f);
    //                    tmp_cell_center_ztop[tmp_cell] = value;
    //                    bBoundary = true;
    //                }
    //                // 这个CELL 存在3个相邻的CELL
    //                else
    //                {
    //                    // 获取这个CELL在第K（current_layer）层的中心的ZTOP
    //                    double ztop;
    //                    getCellZTop(tmp_cell_id[tmp_cell], current_layer, cellZTop_vec, ztop);
    //                    tmp_cell_center_ztop[tmp_cell] = ztop;
    //                }
    //            }

    //            ////TODO
    //            //current_cell_vertices_value[k] = 1.0f * tmp_cell_center_ztop[0] + 1.0f * tmp_cell_center_ztop[1] + 1.0f * tmp_cell_center_ztop[2];

    //            // 如果不是边界点
    //            if (!bBoundary)
    //            {
    //                float u, v, w;
    //                Interpolator::TRIANGLE tri(grid->cellCoord_vec[tmp_cell_id[0]], grid->cellCoord_vec[tmp_cell_id[1]], grid->cellCoord_vec[tmp_cell_id[2]]);
    //                Interpolator::calcTriangleBarycentric(current_vertex, &tri, u, v, w);

    //                current_cell_vertices_value[k] = u * tmp_cell_center_ztop[0] + v * tmp_cell_center_ztop[1] + w * tmp_cell_center_ztop[2];
    //            }
    //            else
    //            {
    //                // 边界点
    //                current_cell_vertices_value[k] = 0.0f * tmp_cell_center_ztop[0] + 0.0f * tmp_cell_center_ztop[1] + 0.0f * tmp_cell_center_ztop[2];
    //            }
    //        
    //        }

    //        //=========================== 找到7个顶点的ZTOP V

    //        // 存到cellVertexZTop_vec
    //        for (auto k = 0; k < current_cell_vertices_value.size(); ++k)
    //        {
    //            cellVertexZTop_vec.push_back(current_cell_vertices_value[k]);
    //        }

    //        
    //    }
    //}
    //
    //std::cout << "cellVertexZTop_vec.size() = " << cellVertexZTop_vec.size() << std::endl;
    //saveDataToTextFile(cellVertexZTop_vec, "OUTPUT2_ztop.txt");
    //Debug("finish2");
    
}

